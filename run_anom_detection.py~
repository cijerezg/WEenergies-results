import numpy as np
import nn_train_test
from anomalous_kwh_detection import general_anomalies as ga
from anomalous_kwh_detection import slowing_down_meters as sdm
from anomalous_kwh_detection import frequency_analysis as fa
from anomalous_kwh_detection import nn_architectures
import argparse
import utils
import torch



def nn_anomaly_detection(data, model):
    """
    This function computes the anomaly score using neural networks
    as described in the report.

    Parameters
    ----------
    data: array
          This should be the clean KWH signal.
    model: pytorch model
           This is the trained neural network.

    Returns
    -------
    output: array
            This is the prediction of the neural network
    score: array
           This array contains the anomaly scores for all
           meters throughout time.
    """
    data = [data[:, np.newaxis, :]]
    nn_model = nn_train_test.nn_model(model)
    loss, output = nn_model.test(data, ga.testing)
    test_data = data[0][:, 0, 28::]
    delta = ga.nn_anomaly_score(output, test_data)
    return output, delta


def slowing_down_meters_detection(data, factor):
    """
    This function computes the SD score as described in the
    report

    Parameters
    ----------
    data: array
          This should be the clean KWH signal.
    factor: integer
            The factor by which data will be subsampled.
            The length of the data must be divisible by factor.

    Returns
    -------
    array: ndarray
       The SD scores computed for every meter.
    """
    subsampled = sdm.subsampling(data, factor)
    SD = sdm.SD_coefficient(subsampled)
    return SD


def frequency_based_detection(data, low_freq, high_freq=None):
    """
    This function computes the high frequency power.

    Parameters
    ----------
    data: array
          Shape should be (n, m), where n is the number of meters,
          and m is the length (time) of the signal.
    low_freq: integer (smaller than m//2)
              The lower upper value for the frequency band.

    high_freq: integer (optional)
               The upper value for the frequency band.

    Returns
    -------
    array: ndarray
       shape is (n)
    """
    fft_data = fa.fft_calculation(data)
    power = fa.freq_band(fft_data, low_freq, high_freq=high_freq)
    return power


DAYS = 672

parser = argparse.ArgumentParser()
parser.add_argument('filename', help='Filename that contains KWH', nargs="?")
args = parser.parse_args()
path = 'data/'


data = np.load(path+args.filename)
data = data[:, 0:DAYS]


data = utils.data_prepocessing(data)

model_3_layers = nn_architectures.CNN_1D_regression(28, 1, 4, layers=3)
model_5_layers = nn_architectures.CNN_1D_regression(28, 1, 4, layers=5)

model_3_state_dict = torch.load('nn_models/3_layers_state_dict.pth')
model_5_state_dict = torch.load('nn_models/5_layers_state_dict.pth')

model_3_layers.load_state_dict(model_3_state_dict)
model_5_layers.load_state_dict(model_5_state_dict)

out_3, delta_3 = nn_anomaly_detection(data, model_3_layers)
out_5, delta_5 = nn_anomaly_detection(data, model_5_layers)
test_data = data[:, 28::]

SD_7 = slowing_down_meters_detection(data, 7)
SD_14 = slowing_down_meters_detection(data, 14)

freq_250 = frequency_based_detection(data, 250)
freq_300 = frequency_based_detection(data, 300)

data_nns = np.concatenate((out_3[:, :, np.newaxis], out_5[:, :, np.newaxis], test_data[:, :, np.newaxis]), axis=2)
errs_nns = np.concatenate((delta_3[:, :, np.newaxis], delta_5[:, :, np.newaxis]), axis=2)

SDs = np.concatenate((SD_7[:, np.newaxis], SD_14[:, np.newaxis]), axis=1)

freqs = np.concatenate((freq_250[:, np.newaxis], freq_300[:, np.newaxis]), axis=1)

path_results = 'results/'
np.save(path_results+'data_nns.npy', data_nns)
np.save(path_results+'errs_nns.npy', errs_nns)
np.save(path_results+'SDs.npy', SDs)
np.save(path_results+'freqs.npy', freqs)
np.save(path_results+'data.npy', data)
